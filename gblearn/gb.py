"""Functions and classes for interacting with grain boundaries.
"""
import numpy as np
from collections import OrderedDict
from gblearn import msg
from os import path
from tqdm import tqdm

class GrainBoundaryCollection(OrderedDict):
    """Represents a collection of grain boundaries and the unique environments
    between them.

    .. warning:: If you don't specify a path for `store`, any results (such as
      SOAP matrices, ASR, LER, etc. will *not* be saved to disk. Also, they
      won't be loaded from disk if they already exist.

    Args:
        name (str): identifier for this collection.
        root (str): path to the directory where the raw GB atomic descriptions
          are located.
        store (str): path to the :class:`~gblearn.io.ResultStore` root
          directory that this collection's results are stored in.
        rxgbid (str): regex pattern for extracting the `gbid` for each GB. Any
          files that don't match the regex are automatically excluded. The regex
          should include a named group `(?P<gbid>...)` so that the GB id can be
          extracted correctly. If not specified, the file name is used as the
          `gbid`.
        sortkey (function): when `root` is investigated to load GBs, the file
          names are first sorted; here you can specify a custom sorting
          function.
        reverse (bool): for GB file name sorting (see `sortkey`), whether to
          reverse the order.
        nmax (int): bandwidth cutoff for the *radial* basis; determines how the
          SOAP results are handled in the file structure.
        lmax (int): bandwidth cutoff for the *angular* (spherical harmonic)
          basis. See also `nmax`.
        rcut (float): cutoff for the local environment of each atom. See also
          `nmax`.

    Attributes:
        name (str): identifier for this collection.
        root (str): path to the directory where the raw GB atomic descriptions
          are located.
        store (gblearn.io.ResultStore): storage manager for all the
          intermediate results generated by this collection.
        unique (dict): keys are `float` values of `epsilon` for comparing
          environments; values are themselves dictionaries that have keys as
          `tuple` of `(gbid, aid)` with `aid` the id of the atom (row id) in the
          SOAP vector for the GB; value is the SOAP vector already found to be
          unique for that value of `epsilon`.
        equivalent (dict): keys are `float` values of `epsilon` for comparing
          environments; values are themselves dictionaries that have `gbid` keys
          values are a `dict` having linked keys with :attr:`unique` and values
          a list of `aid` in the GB whose LAEs that are equivalent to the unique
          LAE represented by the key.
    """
    def __init__(self, name, root, store=None, rxgbid=None, sortkey=None,
                 reverse=False, nmax=None, lmax=None, rcut=None):
        self.name = name
        self.root = path.abspath(path.expanduser(root))
        
        self._sortkey = sortkey
        """function: when `root` is investigated to load GBs, the file names are first
          sorted; here you can specify a custom sorting function.
        """
        self._reverse = reverse
        """bool: for GB file name sorting (see `sortkey`), whether to reverse
        the order.
        """        
        self._rxgbid = None
        """_sre.SRE_Pattern: compiled regex for the gbid pattern matching
        string.
        """
        self.unique = {}
        self.equivalent = {}
        
        if rxgbid is not None:
            import re
            self._rxgbid = re.compile(rxgbid)

        #Search for all the GBs in the specified root folder.
        self.gbfiles = OrderedDict()
        self._find_gbs()

        self.store = None
        if store is not None:
            from gblearn.io import ResultStore
            self.store = ResultStore(self.gbfiles.keys(), store, nmax, lmax, rcut)
        
    def _find_gbs(self):

        """Finds all the GBs in the root directory using the regex.
        """
        from os import walk
        allfiles = []
        for (dirpath, dirnames, filenames) in walk(self.root):
            allfiles.extend(filenames)
            break

        for fname in sorted(allfiles, key=self._sortkey, reverse=self._reverse):
            if self._rxgbid is not None:
                gbmatch = self._rxgbid.match(fname)
                if gbmatch:
                    try:
                        gbid = gbmatch.group("gbid")
                        self.gbfiles[gbid] = path.join(self.root, fname)
                    except IndexError:
                        pass
            else:
                self.gbfiles[fname] = path.join(self.root, fname)

        msg.info("Found {} grain boundaries.".format(len(self.gbfiles)))

    def load(self, parser=None, soapargs=None, **kwargs):
        """Loads the GBs from their files to create :class:`GrainBoundary`
        objects.

        .. note:: The :class:`GrainBoundary` objects are stored in this objects
          dictionary (it inherits from :class:`~collections.OrderedDict`). Thus
          :attr:`keys` are the `gbid` and :attr:`values` are the
          :class:`GrainBoundary` instances, in the sorted order that they were
          discovered.

        .. warning:: You must specify `soapargs` during loading if you plan to
          calculate or use SOAP vectors. If you already set SOAP args when this
          object was constructed, you can ignore this warning.

        Args:
            parser: object used to parse the raw GB file. Defaults to
              :class:`gblearn.lammps.Timestep`. Class should have a method `gb`
              that constructs a :class:`GrainBoundary` instance.
            kwargs (dict): keyword arguments passed to the `gb` method of
             `parser`. For example, see :meth:`gblearn.lammps.Timestep.gb`.
        """
        if parser is None:
            from gblearn.lammps import Timestep
            parser = Timestep

        if soapargs is None:
            #We have this seemingly trivial step because the :meth:`gb` below
            #expects a dictionary for soapargs, but we want to have a
            #non-mutable default value.
            soapargs = {}
        kwargs["soapargs"] = soapargs
            
        for gbid, gbpath in tqdm(self.gbfiles.items()):
            t = Timestep(gbpath)
            gb = t.gb(**kwargs)
            self[gbid] = gb

        #Important! Set the SOAP parameters on the results store. We'll use the
        #soap parameters from the latest gb's calculator.
        if len(self) > 0:
            calc = gb.calculator
            if self.store is not None:
                self.store.SOAP = (calc.nmax, calc.lmax, calc.rcut)
            
    def soap(self, subsel="cna", subpar="c_cna", **kwargs):
        """Calculates the SOAP vector matrix for the atomic environments at
        each grain boundary.

        Args:
            subsel (str): method for subselection of atoms to include
              in the SOAP descriptor. One of ["median", "cna"].
            subpar (str): name of the parameter to pass to the selection
              routine.
            kwargs (dict): additional arguments to pass to the selection
              routine.
        """
        if self.store is not None:
            P = self.store.P
        else:
            P = {}

        if len(P) == len(self):
            #No need to recompute if the store has the result.
            return P
            
        for gbid, gb in tqdm(self.items()):
            P[gbid] = gb.soap(subsel, subpar, **kwargs)

        #Save the matrices to the store if it is available.
        if self.store is not None:
            self.store.P = P

    @property
    def P(self):
        """Returns the computed SOAP matrices for each GB in the collection.
        """
        result = None
        if self.store is not None:
            result = self.store.P

        if result is None or len(result) == 0:
            msg.info("The SOAP matrices haven't been computed yet. Use "
                     ":meth:`soap`.")
            
        return result
            
    @property
    def ASR(self):
        """Returns the ASR for the GB collection.
        """
        result = None
        if self.store is not None:
            result = self.store.ASR

        if result is None and self.P is not None:
            P = self.P
            soaps = []
            for gbid, Pi in P.items():
                soaps.append(np.sum(Pi, axis=0))

            result = np.vstack(soaps)
            if self.store is not None:
                self.store.ASR = result

        return result

    def uniquify(self, epsilon):
        """Extracts all the unique LAEs in the entire GB system using the
        specified `epsilon` similarity value.

        .. warning:: This method does not verify the completion status of any
          previous :meth:`uniquify` attempts. It just re-runs everything and
          clobbers any existing results for the specified value of `epsilon`.

        Args:
            eps (float): similarity scores below this value are considered
              identical. Two actually identical GBs will have a similarity score
              of `0` by this metric, so smaller is more similar.
        """
        if self.P is None:
            return

        unique = {}
        equivalent = {}

        #Pre-seed the unique list with the first environment in the first GB for
        #optimization purposes.
        first = next(self.keys())
        P0 = self.P[first][0,:]
        unique[(first, 0)] = P0
        
        from gblearn.soap import S
        #Outer loop is over all GBs in the collection.
        for gbid, Pi in tqdm(self.P.items()):
            #Inner loop is over the indvidual SOAP vectors in the current GB
            #that we are examining. At this point, the keys in equivalencies
            #list must either come from a previous GB, or they will be added by
            #this one. So, we can pre-seed this dictionary.
            equivalencies = {k: [] for k in unique}
            
            for i in range(len(Pi)):
                Pv = Pi[i,:]
                
                #Comparison loop is over all the vectors found to be unique so
                #far. If the vector is unique, add it to the list; otherwise add
                #its equivalency to the relevant list.
                for fid, u in unique.items():
                    if (1. - S(Pv, u)) < epsilon:
                        #These vectors are considered to be equivalent. Store
                        #the equivalency.
                        equivalencies[fid].append(i)
                        break
                else:
                    unique[(gbid, i)] = Pv
                    equivalencies[(gbid, i)] = [i]

            equivalent[gbid] = equivalencies

        self.unique[epsilon] = unique
        self.equivalent[epsilon] = equivalent
                
        return result        
        
class GrainBoundary(object):
    """Represents a grain boundary that is defined by a list of atomic
    positions.

    Args:
        xyz (numpy.ndarray): cartesian position of the atoms at the
          boundary. Shape is `(N, 3)`.
        types (numpy.ndarray): of `int` atom types for each atom in the
          `xyz` list.
        box (numpy.ndarray): box dimensions in cartesian directions in
          format `lo` `hi`. Shape `(3, 2)`.
        Z (int): element code for the atomic species.        
        extras (dict): keys are additional atomic attributes; values are lists
          of attribute values. Value arrays must have same length as `xyz`.
        soapargs (dict): keyword arguments to pass to the constructor of the
          :class:`~gblearn.soap.SOAPCalculator` that will be used to calculate
          the `P` matrix for this GB.

    Attributes:
        xyz (numpy.ndarray): cartesian position of the atoms at the
          boundary. Shape is `(N, 3)`.
        types (numpy.ndarray): of `int` atom types for each atom in the
          `xyz` list.
        box (numpy.ndarray): box dimensions in cartesian directions in
          format `lo` `hi`. Shape `(3, 2)`.
        lattice (numpy.ndarray): array of lattice vector for the grain boundary
          box; this includes padding in the x-direction to allow a "surface" for
          the outermost atoms of the GB slice.
        calculator (~gblearn.soap.SOAPCalculator): calculator for getting the
          SOAP vector matrix for this GB.
        Z (int): element code for the atomic species.
        P (numpy.ndarray): SOAP vector matrix; shape `(N, S)`, where `N` is the
          number of atoms at the boundary and `S` is the dimensionality of the
          SOAP vector space (which varies with SOAP parameters).
    """
    def __init__(self, xyz, types, box, Z, extras=None, **soapargs):
        from gblearn.soap import SOAPCalculator
        self.xyz = xyz
        self.types = types
        self.box = box
        self.lattice = np.array([[35., 0., 0.],
                                 [box[1][0], box[1][1], 0.],
                                 [box[2][0], 0., box[2][1]]])
        self.calculator = SOAPCalculator(**soapargs)
        self.Z = Z

        if extras is not None:
            for k, v in extras.items():
                setattr(self, k, v)
        
        self.P = None
        self._atoms = None
        """quippy.atoms.Atoms: representation of the atoms at the boundary that
        is interoperable with QUIP.
        """
        self._NP = None
        """numpy.ndarray: normalized P matrix, where each row is normalized by
        its L2 norm.
        """
        self._K = None
        """numpy.ndarray: matrix of the dot product of every row in :attr:`NP`
        with every other row.
        """
        
    def __len__(self):
        return len(self.xyz)

    @property
    def NP(self):
        """Returns the *normalized* P matrix where each row is normalized by its
        norm.
        """
        if self._NP is None:
            P = self.soap
            pself = np.array([np.dot(p, p) for p in P])
            self._NP = np.array([P[i,:]/np.sqrt(pself[i])
                                 for i in range(len(P))
                                 if pself[i] > 0])
        return self._NP

    @property
    def K(self):
        """Returns the kernel similarity matrix between for the P matrix of this
        grain boundary.
        """
        if self._K is None:
            NP = self.NP
            self._K = np.dot(NP, NP.T)
        return self._K

    def load(self, attr, filepath):
        """Loads a SOAP matrix `P` for this GB from serialized file.

        Args:
            attr (str): attribute to load from file; one of ['P', 'R'].
            filepath (str): full path to the file to load.
        """
        from os import path
        if path.isfile(filepath):
            setattr(self, attr, np.load(filepath))
    
    def soap(self, subsel=None, subpar=None, **kwargs):
        """Calculates the SOAP vector matrix for the atomic environments at the
        grain boundary.

        Args:
            subsel (str): method for subselection of atoms to include
              in the SOAP descriptor. One of ["median", "cna"].
            subpar (str): name of the parameter to pass to the selection
              routine.
            kwargs (dict): additional arguments to pass to the selection
              routine.
        """
        if self.P is None:
            self.P = self.calculator.calc(self.atoms, self.Z)

            if subsel is not None:
                import gblearn.selection as sel
                methmap = {
                    "median": sel.median,
                    "cna": sel.cna_max
                }
                if subsel in methmap:
                    ids = methmap[subsel](self.xyz, getattr(self, subpar),
                                          types=self.types, **kwargs)
                    self.P = self.P[ids,:]

        return self.P

    @property
    def atoms(self):
        """Returns an atoms object for the boundary that can be used for
        calculating the SOAP vectors.

        Args:
            Z (int): element code for the atomic species.
        """
        if self._atoms is None:
            from quippy.atoms import Atoms
            a = Atoms(lattice=self.lattice)
            for xyz in self.xyz:
                a.add_atoms(xyz, self.Z)
            self._atoms = a
        return self._atoms
        
    def save_xyz(self, filename, species=None, vacuum=False):
        """Writes the grain boundary atoms to extended XYZ file format
        that can be used with QUIP.

        Args:
            filename (str): name/path to the file to save to.
            species (str): element name.
        """
        from os import path
        filepath = path.abspath(path.expanduser(filename))

        if vacuum:
            #8
            #Lattice="5.44 0.0 0.0 0.0 5.44 0.0 0.0 0.0 5.44" Properties=species:S:1:pos:R:3 Time=0.0
            #Si        0.00000000      0.00000000      0.00000000
            #For the y and z lattice vectors, we just get the box values from
            #the original files. For x, we make the lattice large so that there is a bunch of
            #space around the slice.
            LVs = ' '.join(["{0:.5f} {1:.5f} {2:.5f}".format(*v)
                            for v in self.lattice])
            with open(filepath, 'w') as f:
                f.write("{0:d}\n".format(len(self.xyz)))
                f.write('Lattice="{}" Properties=species:S:1:pos:R:3\n'.format(LVs))
                afmt = "{0}    {1:.5f}    {2:.5f}    {3:.5f}\n"
                for xyz in self.xyz:
                    f.write(afmt.format(species, *xyz))
        else:
            import quippy.cinoutput as qcio
            out = qcio.CInOutputWriter(filepath)
            self.atoms.write(out)
            out.close()                    
